1简介

GCC 的意思也只是 GNU C Compiler 而已。经过了这么多年的发展，GCC 已经不仅仅能支持 C 语言；它现在还支持 Ada 语言、C++ 语言、Java 语言、Objective C 语言、Pascal 语言、COBOL语言，以及支持函数式编程和逻辑编程的 Mercury 语言，等等。而 GCC 也不再单只是 GNU C 语言编译器的意思了，而是变成了 GNU Compiler Collection 也即是 GNU 编译器家族的意思了。另一方面，说到 GCC 对于操作系统平台及硬件平台支持，概括起来就是一句话：无所不在。

2简单编译

示例程序如下：

复制代码
//test.c
#include <stdio.h>
int main(void)
{
    printf("Hello World!\n");
    return 0;
}
复制代码
这个程序，一步到位的编译指令是:

gcc test.c -o test



实质上，上述编译过程是分为四个阶段进行的，即预处理(也称预编译，Preprocessing)、编译(Compilation)、汇编 (Assembly)和连接(Linking)。

2.1预处理
gcc -E test.c -o test.i 或 gcc -E test.c
 

可以输出test.i文件中存放着test.c经预处理之后的代码。打开test.i文件，看一看，就明白了。后面那条指令，是直接在命令行窗口中输出预处理后的代码.

gcc的-E选项，可以让编译器在预处理后停止，并输出预处理结果。在本例中，预处理结果就是将stdio.h 文件中的内容插入到test.c中了。

2.2编译为汇编代码(Compilation)
预处理之后，可直接对生成的test.i文件编译，生成汇编代码：

gcc -S test.i -o test.s
gcc的-S选项，表示在程序编译期间，在生成汇编代码后，停止，-o输出汇编代码文件。

2.3汇编(Assembly)
对于上一小节中生成的汇编代码文件test.s，gas汇编器负责将其编译为目标文件，如下：

gcc -c test.s -o test.o
2.4连接(Linking)
gcc连接器是gas提供的，负责将程序的目标文件与所需的所有附加的目标文件连接起来，最终生成可执行文件。附加的目标文件包括静态连接库和动态连接库。

对于上一小节中生成的test.o，将其与Ｃ标准输入输出库进行连接，最终生成程序test

gcc test.o -o test
 

在命令行窗口中，执行./test, 让它说HelloWorld吧！

3多个程序文件的编译

通常整个程序是由多个源文件组成的，相应地也就形成了多个编译单元，使用GCC能够很好地管理这些编译单元。假设有一个由test1.c和 test2.c两个源文件组成的程序，为了对它们进行编译，并最终生成可执行程序test，可以使用下面这条命令：

gcc test1.c test2.c -o test

如果同时处理的文件不止一个，GCC仍然会按照预处理、编译和链接的过程依次进行。如果深究起来，上面这条命令大致相当于依次执行如下三条命令：

gcc -c test1.c -o test1.o
gcc -c test2.c -o test2.o
gcc test1.o test2.o -o test



4检错

gcc -pedantic illcode.c -o illcode
-pedantic编译选项并不能保证被编译程序与ANSI/ISO C标准的完全兼容，它仅仅只能用来帮助Linux程序员离这个目标越来越近。或者换句话说，-pedantic选项能够帮助程序员发现一些不符合 ANSI/ISO C标准的代码，但不是全部，事实上只有ANSI/ISO C语言标准中要求进行编译器诊断的那些情况，才有可能被GCC发现并提出警告。

除了-pedantic之外，GCC还有一些其它编译选项也能够产生有用的警告信息。这些选项大多以-W开头，其中最有价值的当数-Wall了，使用它能够使GCC产生尽可能多的警告信息。

gcc -Wall illcode.c -o illcode
GCC给出的警告信息虽然从严格意义上说不能算作错误，但却很可能成为错误的栖身之所。一个优秀的Linux程序员应该尽量避免产生警告信息，使自己的代码始终保持标准、健壮的特性。所以将警告信息当成编码错误来对待，是一种值得赞扬的行为！所以，在编译程序时带上-Werror选项，那么GCC会在所有产生警告的地方停止编译，迫使程序员对自己的代码进行修改，如下：

gcc -Werror test.c -o test
 


5库文件连接

开发软件时，完全不使用第三方函数库的情况是比较少见的，通常来讲都需要借助许多函数库的支持才能够完成相应的功能。从程序员的角度看，函数库实际上就是一些头文件（.h）和库文件（so、或lib、dll）的集合。。虽然Linux下的大多数函数都默认将头文件放到/usr/include/目录下，而库文件则放到/usr/lib/目录下；Windows所使用的库文件主要放在Visual Stido的目录下的include和lib，以及系统文件夹下。但也有的时候，我们要用的库不再这些目录下，所以GCC在编译时必须用自己的办法来查找所需要的头文件和库文件。

例如我们的程序test.c是在linux上使用c连接mysql，这个时候我们需要去mysql官网下载MySQL Connectors的C库，下载下来解压之后，有一个include文件夹，里面包含mysql connectors的头文件，还有一个lib文件夹，里面包含二进制so文件libmysqlclient.so

其中inclulde文件夹的路径是/usr/dev/mysql/include,lib文件夹是/usr/dev/mysql/lib

 

5.1编译成可执行文件
首先我们要进行编译test.c为目标文件，这个时候需要执行

gcc –c –I /usr/dev/mysql/include test.c –o test.o
5.2链接
最后我们把所有目标文件链接成可执行文件:

gcc –L /usr/dev/mysql/lib –lmysqlclient test.o –o test
Linux下的库文件分为两大类分别是动态链接库（通常以.so结尾）和静态链接库（通常以.a结尾），二者的区别仅在于程序执行时所需的代码是在运行时动态加载的，还是在编译时静态加载的。

5.3强制链接时使用静态链接库
默认情况下， GCC在链接时优先使用动态链接库，只有当动态链接库不存在时才考虑使用静态链接库，如果需要的话可以在编译时加上-static选项，强制使用静态链接库。

在/usr/dev/mysql/lib目录下有链接时所需要的库文件libmysqlclient.so和libmysqlclient.a，为了让GCC在链接时只用到静态链接库，可以使用下面的命令:

gcc –L /usr/dev/mysql/lib –static –lmysqlclient test.o –o test
 

静态库链接时搜索路径顺序：

1. ld会去找GCC命令中的参数-L
2. 再找gcc的环境变量LIBRARY_PATH
3. 再找内定目录 /lib /usr/lib /usr/local/lib 这是当初compile gcc时写在程序内的

动态链接时、执行时搜索路径顺序:

1. 编译目标代码时指定的动态库搜索路径
2. 环境变量LD_LIBRARY_PATH指定的动态库搜索路径
3. 配置文件/etc/ld.so.conf中指定的动态库搜索路径
4. 默认的动态库搜索路径/lib
5. 默认的动态库搜索路径/usr/lib

有关环境变量：
LIBRARY_PATH环境变量：指定程序静态链接库文件搜索路径
LD_LIBRARY_PATH环境变量：指定程序动态链接库文件搜索路径



**********************************************************************************************

gcc 编译器常用的命令行参数一览
这些常用的 gcc/g++ 命令行参数，你都知道么？

1. gcc -E source_file.c
-E，只执行到预编译。直接输出预编译结果。

2. gcc -S source_file.c 
-S，只执行到源代码到汇编代码的转换，输出汇编代码。

3. gcc -c source_file.c
-c，只执行到编译，输出目标文件。

4. gcc (-E/S/c/) source_file.c -o output_filename
-o, 指定输出文件名，可以配合以上三种标签使用。
-o 参数可以被省略。这种情况下编译器将使用以下默认名称输出：
-E：预编译结果将被输出到标准输出端口（通常是显示器）
-S：生成名为source_file.s的汇编代码
-c：生成名为source_file.o的目标文件。
无标签情况：生成名为a.out的可执行文件。

5. gcc -g source_file.c 
-g，生成供调试用的可执行文件，可以在gdb中运行。由于文件中包含了调试信息因此运行效率很低，且文件也大不少。
这里可以用strip命令重新将文件中debug信息删除。这是会发现生成的文件甚至比正常编译的输出更小了，这是因为strip把原先正常编译中的一些额外信息（如函数名之类）也删除了。用法为 strip a.out

6. gcc -s source_file.c
-s, 直接生成与运用strip同样效果的可执行文件（删除了所有符号信息）。

7. gcc -O source_file.c
-O（大写的字母O），编译器对代码进行自动优化编译，输出效率更高的可执行文件。
-O 后面还可以跟上数字指定优化级别，如：
gcc -O2 source_file.c
数字越大，越加优化。但是通常情况下，自动的东西都不是太聪明，太大的优化级别可能会使生成的文件产生一系列的bug。一般可选择2；3会有一定风险。

8. gcc -Wall source_file.c
-W，在编译中开启一些额外的警告（warning）信息。-Wall，将所有的警告信息全开。

9. gcc source_file.c -L/path/to/lib -lxxx -I/path/to/include
-l, 指定所使用到的函数库，本例中链接器会尝试链接名为libxxx.a的函数库。
-L，指定函数库所在的文件夹，本例中链接器会尝试搜索/path/to/lib文件夹。
-I, 指定头文件所在的文件夹，本例中预编译器会尝试搜索/path/to/include文件夹。

**********************************************************************************************





GCC 选项  
GCC 有超过100个的编译选项可用. 这些选项中的许多你可能永远都不会用到, 但一些主要的选项将会频繁用到. 很多的 GCC 选项包括一个以上的字符.
因此你必须为每个选项指定各自的连字符, 并且就象大多数 Linux 命令一样你不能在一个单独的连字符后跟一组选项. 例如, 下面的两个命令是不同的:  
gcc -p -g test.c  
 
gcc -pg test.c  
第一条命令告诉 GCC 编译 test.c 时为 prof 命令建立剖析(profile)信息并且把调试信息加入到可执行的文件里. 第二条命令只告诉 GCC 为 gprof 命令建立剖析信息.  
 
当你不用任何选项编译一个程序时,  GCC 将会建立(假定编译成功)一个名为a.out 的可执行文件. 例如, 下面的命令将在当前目录下产生一个叫 a.out 的文件:  
gcc test.c  
你能用 -o 编译选项来为将产生的可执行文件指定一个文件名来代替 a.out. 
例如, 将一个叫 count.c 的 C 程序编译为名叫 count 的可执行文件, 你将输入下面的命令:  
gcc -o count count.c  
 
注意: 当你使用 -o 选项时, -o 后面必须跟一个文件名. 
-c 只编译并生成目标文件。  
 
--------------------------------------------------------------------------------  
gcc  and  g++分别是gnu的c  &  c++编译器 gcc/g++在执行编译工作的时候，总共需要4步 
 
1.预处理,生成.i的文件 [预处理器cpp]  
2.将预处理后的文件不转换成汇编语言,生成文件.s[编译器egcs]  
3.有汇编变为目标代码(机器代码)生 成.o的文件[汇编器as]  
4.连接目标代码,生成可执行程序[链接器ld]  
[参数详解]  
-x language filename  
  设定文件所使用的语言,使后缀名无效,对以后的多个有效.也就是根据约定C语言的后缀名称是.c 的，而C++的 后缀名是.C 或者.cpp,如果你很个性，决定你的C代码文件的后缀名是.pig 哈哈，那你就要用这个参数,这个参数对他后面的文件名都起作用，除非到了下一个参数的使用。 可以使用的参数吗有下面的这些   `c', `objective-c', `c-header', `c++', `cpp-output', `assembler', and `assembler-with-cpp'.  看到英文，应该可以理解的。  
  例子用法:  
  gcc -x c hello.pig  
    
-x none filename  
  关掉上一个选项，也就是让gcc根据文件名后缀，自动识别 文件类型  
  例子用法:  
  gcc -x c hello.pig -x none hello2.c  
    
-c  
  只激活预处理,编译,和汇编,也就是他只把程序做成obj文件  
  例子用法:  
  gcc -c hello.c  
   他将生成.o的obj文件  
-S  
  只激活预处理和编译，就是指把文件编译成为汇编代码。  
  例子用法  
   gcc -S hello.c  
  他将生成.s的汇编代码，你可以用文本编辑器察看  
-E  
  只激活预处理,这个不生成文 件,你需要把它重定向到一个输出文件里面.  
  例子用法:  
  gcc -E hello.c > pianoapan.txt  
  gcc -E hello.c | more  
  慢慢看吧,一个hello word 也要与处理成800行的代码  
-o  
  制定目标名称,缺省的时候,gcc 编译出来的文件是a.out,很难听,如果你和我有同感，改掉它,哈哈  
  例子用 法  
  gcc -o hello.exe hello.c (哦,windows用习惯了)  
  gcc -o hello.asm -S hello.c  
-pipe  
  使用管道代替编译中临时文件,在使用非gnu汇编工具的时候,可能有些问题  
  gcc -pipe -o hello.exe hello.c  
-ansi  
  关闭gnu c中与ansi c不兼容的特性,激活ansi c的专有特性(包括禁止一些asm inline typeof关键字,以及UNIX,vax等预处理宏,  
-fno-asm  
   此选项实现ansi选项的功能的一部分，它禁止将asm,inline和typeof用作关键字。  
      
-fno-strict-prototype  
  只对g++起作用,使用这个选项,g++将对不带参数的函数,都认为是没有显式的对参数的个数和类型说明,而不是没有参数.  
   而gcc无论是否使用这个参数,都将对没有带参数的函数,认为城没有显式说明的类型  
 
    
-fthis-is-varialble  
  就是向传统c++看齐,可以使用this当一般变量使用.  
    
-fcond-mismatch  
  允许条件 表达式的第二和第三参数类型不匹配,表达式的值将为void类型  
    
-funsigned-char  
-fno-signed-char  
-fsigned-char  
-fno-unsigned-char  
  这四个参数是对char类型进行设置,决定将 char类型设置成unsigned char(前两个参数)或者 signed char(后两个参数)  
    
-include file  
  包含某个代码,简单来说,就是便以某个文件,需要另一个文件的时候,就可以用它设定,功能就相当于在代码中使 用#include<filename>  
  例子用法:  
  gcc hello.c -include /root/pianopan.h  
    
-imacros file  
  将file文件的宏,扩展到gcc/g++的输入文 件,宏定义本身并不出现在输入文件中  
    
-Dmacro  
  相当于C语言中的#define macro  
    
-Dmacro=defn  
  相当于C语言中的#define macro=defn  
    
-Umacro  
  相当于C语言中 的#undef macro  
-undef  
  取消对任何非标准宏的定义  
    
-Idir  
  在你是 用#include"file"的时候,gcc/g++会先在当前目录查找你所制定的头文件,如果没有找到,他回到缺省的头文件目录找,如果使 用-I制定了目录,他会先在你所制定的目录查找,然后再按常规的顺序去找.  
  对 于#include<file>,gcc/g++会到-I制定的目录查找,查找不到,然后将到系统的缺省的头文件目录查找  
     
-I-  
  就是取消前一个参数的功能,所以一般在-Idir之后使用  
    
-idirafter dir  
   在-I的目录里面查找失败,讲到这个目录里面查找.  
    
-iprefix prefix  
-iwithprefix dir  
  一般一起使用,当-I的目录查找失败,会到prefix+dir下查找  
    
-nostdinc  
  使 编译器不再系统缺省的头文件目录里面找头文件,一般和-I 联合使用,明确限定头文件的位置  
    
-nostdin C++  
     规定不在g++指定的标准路经中搜索,但仍在其他路径中搜索,.此选项在创libg++库使用  
    
-C  
  在 预处理的时候,不删除注释信息,一般和-E使用,有时候分析程序，用这个很方便的  
 
    
-M  
  生成文件关联的信 息。包含目标文件所依赖的所有源代码你可以用gcc -M hello.c来测试一下，很简单。  
    
-MM  
   和上面的那个一样，但是它将忽略由#include<file>造成的依赖关系。  
    
-MD  
  和-M相同， 但是输出将导入到.d的文件里面  
    
-MMD  
  和-MM相同，但是输出将导入到.d的文件里面  
    
-Wa,option  
  此选项传递option给汇编程序;如果option中间有逗号,就将option分成多个选项,然后传递给会汇编程序  
     
-Wl.option  
  此选项传递option给连接程序;如果option中间有逗号,就将option分成多个选项,然后 传递给会连接程序.  
    
-llibrary  
  制定编译的时候使用的库  
  例子用法  
  gcc -lcurses hello.c  
  使用ncurses库编译程序  
    
-Ldir  
  制定编译的时候，搜索库 的路径。比如你自己的库，可以用它制定目录，不然编译器将只在标准库的目录找。这个dir就是目录的名称。  
    
-O0  
-O1  
-O2  
-O3  
  编译器的优化选项的4个级别，-O0表示没有优化,-O1为缺省值，-O3优化级别最高    
      
-g  
  只是编译器，在编译的时候，产生调试信息。  
    
-gstabs  
  此选 项以stabs格式声称调试信息,但是不包括gdb调试信息.  
    
-gstabs+  
  此选项以stabs格式声称调试信 息,并且包含仅供gdb使用的额外调试信息.  
    
-ggdb  
  此选项将尽可能的生成gdb的可以使用的调试信息.  
-static  
  此选项将禁止使用动态库，所以，编译出来的东西，一般都很大，也不需要什么动态连接库，就可以运行.  
-share  
    此选项将尽量使用动态库，所以生成文件比较小，但是需要系统由动态库.  
-traditional  
  试图让编译器支持传统的C语言 特性  
[参考资料]  
-Linux/UNIX高级编程  
  中科红旗软件技术有限公司编著.清华大学出版社出版  
-Gcc man page  
    
[ChangeLog]  
-2002-08-10  
  ver 0.1 发布最初的文档  
-2002-08-11  
  ver 0.11 修改文档格式  
-2002-08-12  
  ver 0.12 加入了对静态库，动态库的参数  
-2002-08-16  
  ver 0.16 增加了gcc编译的4个阶段的命令  
运行 gcc/egcs  
**********运行 gcc/egcs***********************  
  GCC 是 GNU 的 C 和 C++ 编译器。实际上，GCC 能够编译三种语言：C、C++ 和 Object  C（C 语言的一种面向对象扩展）。利用 gcc 命令可同时编译并连接 C和 C++源程序。 
  如果你有两个或少数几个 C 源文件，也可以方便地利用 GCC 编译、连接并生成可执行文件。例如，假设你有两个源文件 main.c 和 factorial.c 两个源文件，现在要编译生成一个计算阶乘的程序。  
代码:  
-----------------------  
清单 factorial.c  
-----------------------  
int factorial (int n)  
{  
  if (n <= 1)  
   return 1;  
  else  
   return factorial (n - 1) * n;  
}  
-----------------------  
清单 main.c  
-----------------------  
#include <stdio.h>  
#include <unistd.h>  
int factorial (int n);  
int main (int argc, char **argv)  
{  
  int n;  
  if (argc < 2)  
  {  
    printf ("Usage: %s n\n", argv [0]);  
    return -1;  
  }  
  else  
  {  
   n = atoi (argv[1]);  
   printf ("Factorial of %d is %d.\n", n, factorial (n));  
   }  
  return 0;  
}  
-----------------------  
利用如下的命令可 编译生成可执行文件，并执行程序：  
$ gcc -o factorial main.c factorial.c  
$ ./factorial 5  
Factorial of 5 is 120.  
  GCC 可同时用来编译 C 程序和 C++ 程序。一般来说，C 编译器通过源文件的后缀名来判断是  C 程序还是  C++ 程序。在  Linux 中，C 源文件的后缀名为 .c，而 C++ 源文件的后缀名为 .C 或 .cpp。但是，gcc 命令只能编译 C++ 源文件，而不能自动和 C++ 程序使用的库连接。因此，通常使用 g++ 命令来完成 C++ 程序的编译和连接，该程序会自动调用  gcc 实现编译。假设我们有一个如下的  C++ 源文件（hello.C）：  
#include <iostream>  
void main (void)  
{  
  cout << "Hello, world!" << endl;  
}  
则可以如下调用 g++ 命令编译、连接并生成可执行文件：  
$ g++ -o hello hello.C  
$ ./hello  
Hello, world!  
**********************gcc/egcs 的主要选项*********  
gcc 命令的常用选项  
选项 解释  
-ansi 只支持 ANSI 标准的 C 语法。这一选项将禁止 GNU C 的某些特色，  
例如 asm 或 typeof 关键词。  
-c 只编译并生成目标文件。  
-DMACRO 以字符串“1”定义 MACRO 宏。  
-DMACRO=DEFN 以字符串“DEFN”定义 MACRO 宏。  
-E 只运行 C 预编译器。  
-g 生成调试信息。GNU 调试器可利用该信息。  
-IDIRECTORY 指定额外的头文件搜索路径DIRECTORY。  
-LDIRECTORY 指定额外的函数库搜索路径DIRECTORY。  
-lLIBRARY 连接时搜索指定的函数库LIBRARY。  
-m486 针对 486 进行代码优化。  
-o FILE 生成指定的输出文件。用在生成可执行文件时。  
-O0 不进行优化处理。  
-O 或 -O1 优化生成代码。  
-O2 进一步优化。  
-O3 比 -O2 更进一步优化，包括 inline 函数。  
-shared 生成共享目标文件。通常用在建立共享库时。  
-static 禁止使用共享连接。  
-UMACRO 取消对 MACRO 宏的定义。  
-w 不生成任何警告信息。  
-Wall 生成所有警告信息。



 linux ar命令
 
当我们的程序中有经常使用的模块，而且这种模块在其他程序中也会用到，这时按照软件重用的思想，我们应该将它们生成库，使得以后编程可以减少开发代码量。这里介绍命令ar，用来对库操作。 
1.ar基本用法
　　ar命令可以用来创建、修改库，也可以从库中提出单个模块。库是一单独的文件，里面包含了按照特定的结构组织起来的其它的一些文件（称做此库文件的member）。原始文件的内容、模式、时间戳、属主、组等属性都保留在库文件中。
　　下面是ar命令的格式：
　　ar [-]{dmpqrtx}[abcfilNoPsSuvV] [membername] [count] archive files...
　　例如我们可以用ar rv libtest.a hello.o hello1.o来
生成一个库，库名字是test，链接时可以用-ltest链接。该库中存放了两个模块hello.o和hello1.o。选项前可以有‘-'字符，也可以
没有。下面我们来看看命令的操作选项和任选项。现在我们把{dmpqrtx}部分称为操作选项，而[abcfilNoPsSuvV]部分称为任选项。
　　{dmpqrtx}中的操作选项在命令中只能并且必须使用其中一个，它们的含义如下：

d：从库中删除模块。按模块原来的文件名指定要删除的模块。如果使用了任选项v则列出被删除的每个模块。
m：该操作是在一个库中移动成员。当库中如果有若干模块有相同的符号定义(如函数定义)，则成员的位置顺序很重要。如果没有指定任选项，任何指定的成员将移到库的最后。也可以使用'a'，'b'，或'i'任选项移动到指定的位置。
p：显示库中指定的成员到标准输出。如果指定任选项v，则在输出成员的内容前，将显示成员的名字。如果没有指定成员的名字，所有库中的文件将显示出来。
q：快速追加。增加新模块到库的结尾处。并不检查是否需要替换。'a'，'b'，或'i'任选项对此操作没有影响，模块总是追加的库的结尾处。如果使用了任选项v则列出每个模块。 这时，库的符号表没有更新，可以用'ar s'或ranlib来更新库的符号表索引。
r：在库中插入模块(替换)。当插入的模块名已经在库中存在，则替换同名的模块。如果若干模块中有一个模块在库中不存在，ar显示一个错误消息，并不替换其他同名模块。默认的情况下，新的成员增加在库的结尾处，可以使用其他任选项来改变增加的位置。
t：显示库的模块表清单。一般只显示模块名。
x：从库中提取一个成员。如果不指定要提取的模块，则提取库中所有的模块。

　　下面在看看可与操作选项结合使用的任选项：

a：在库的一个已经存在的成员后面增加一个新的文件。如果使用任选项a，则应该为命令行中membername参数指定一个已经存在的成员名。
b：在库的一个已经存在的成员前面增加一个新的文件。如果使用任选项b，则应该为命令行中membername参数指定一个已经存在的成员名。
c：创建一个库。不管库是否存在，都将创建。
f：在库中截短指定的名字。缺省情况下，文件名的长度是不受限制的，可以使用此参数将文件名截短，以保证与其它系统的兼容。
i：在库的一个已经存在的成员前面增加一个新的文件。如果使用任选项i，则应该为命令行中membername参数指定一个已经存在的成员名(类似任选项b)。
l：暂未使用
N：与count参数一起使用，在库中有多个相同的文件名时指定提取或输出的个数。
o：当提取成员时，保留成员的原始数据。如果不指定该任选项，则提取出的模块的时间将标为提取出的时间。
P：进行文件名匹配时使用全路径名。ar在创建库时不能使用全路径名（这样的库文件不符合POSIX标准），但是有些工具可以。
s：写入一个目标文件索引到库中，或者更新一个存在的目标文件索引。甚至对于没有任何变化的库也作该动作。对一个库做ar s等同于对该库做ranlib。
S：不创建目标文件索引，这在创建较大的库时能加快时间。
u：一般说来，命令ar r...插入所有列出的文件到库中，如果你只想插入列出文件中那些比库中同名文件新的文件，就可以使用该任选项。该任选项只用于r操作选项。
v：该选项用来显示执行操作选项的附加信息。
V：显示ar的版本
